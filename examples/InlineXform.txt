case 1: (trivial, no assignments to variables used in
        actual arg exprs within this stmt)

before:

  a + bar(b) + c;

after:

  final int b_ = b;
  a + (new Inlined() {
      public int intMethod() {
          <body of bar() using b_>
      }
      }).intMethod() + c

case 2: side-effect, no other refs

before:

  a + bar(++b) + c;

after:

  final int b_ = b+1;
  a + (new Inlined() {
      public int intMethod() {
          <body of bar() using b_>
      }
      }).intMethod() + c
  b = b_

case 3: side-effect

before:

  a + b + bar(++b) + b + c;

after:

  final int b_ = b+1;
  a + b + (new Inlined() {
      public int intMethod() {
          <body of bar() using b_>
      }
      }).intMethod() + b_ + c
  b = b_

alternative:

  final int b_ = b+1;
  a + b + (new Inlined() {
      public int intMethod(int dummy) {
          <body of bar() using b_>
      }
      }).intMethod((++b)) + b + c

  // i.e., roll side effects into dummy actual args of synthesized method

  
a + b + bar(++b, o = q, c *= 3) + b + c

  final int b_ = b+1;
  final Object o_ = q;
  final int c_ = c*3;
  a + b + (new Inlined() {
      public int intMethod(Object dummy) {
          <body of bar() using b_, o_, and c_>
      }
      }).intMethod((new Integer(++b), o = q, new Integer(c *= 3), null)) + b + c


case 4: nasty, nasty general case

before:

  a + b + bar(b = foo()) + b + c;

after:

  final int b_ = ????;
  a + b + (new Inlined() {
      public int intMethod(Object dummy) {
          <body of bar() using b_>
      }
      }).intMethod((new Integer(b = foo()), null)) + b + c

correct translation:

  int t1 = a + b;
  int a1 = (b = foo());
  <body of bar() using a1>
  int t2 = return value of bar();
  int t3 = b + c;
  t1 + t2 + t3

========================================================

xform language:

 
 Includes pre-defined predicates/functions for standard static analysis "facts" (e.g. "set of locations
    written to by node N", "set of methods called by node N", "dynamic type of node N")

 LHS pattern
 
  - establish meta-variable bindings

  - pattern over typed AST node structures, with target type constraints (e.g. "type of node N is Object")

 Precondition language
 
  - including access to predicates/functions

 RHS structure w/ meta-variable substitution

  - including access to predicates/functions (e.g., so that one can use static/dynamic type of some node
    in a generated cast)

 need:
   - replace node with node'  : implicit in relationship of LHS/RHS
   - insert stmt' before stmt : implicit in relationship of LHS/RHS
   - create node' with args   : implicit in relationship of LHS/RHS

   E.g. the following visual pattern:
 
           A                  f1(A)
          / \+                 / \+
         B   P                B   P
              \       =>           \
               C                   f2(C)
                \                    \
                 D                    D

    Construed as "A has precisely two children, B and P..., P has precisely one child, C, and ..."

    Concrete syntax looks like this:

                     [A
                        [B]
                        +[P
                           [C
                             [D]]]] =>
                     [f1(A)
                            [B]
                            +[P
                                [f2(C)
                                      [D]]]]

    Possible syntactic sugar for appearance:

                     [A
                      |-[B]
                      \+[P
                         \-[C
                            \-[D]]]] =>
                     [f1(A)
                      |-[B]
                      \+[P
                         \-[f2(C)
                            \-[D]]]]

    In patterns, can use the following to identify ast nodes:

      1) non-terminal name alone (e.g. "Expr", if you don't need to ref it on the RHS)
      2) non-terminal + meta-variable name (e.g. "Expr e1"), or
      3) non-terminal + meta-variable name + target static type constraint (e.g. "Expr e1:int")

    Links are matched "syntactically", e.g. /+ matches /+, but not /+ followed by /.

    Precondition syntax: 1st-order formulas with the following atoms:

      - ast(N) == Expr       [constrains the AST node type of the node N - (1) above is syntactic sugar for this]
      - typeof(N) == Integer [constrains the "target type" in the program of node N - (3) above is syntactic sugar for this]
      - pred(a1,...,ak)      [true if the given args satisfy predicate 'pred'.
                              Valid args are: meta-variables, literals (types, primitive values), node ctors]
